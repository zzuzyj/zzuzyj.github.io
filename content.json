{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://zzuzyj.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-04-18T11:52:10.733Z","updated":"2022-04-18T11:52:10.733Z","comments":false,"path":"/404.html","permalink":"http://zzuzyj.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-18T11:52:10.735Z","updated":"2022-04-18T11:52:10.735Z","comments":false,"path":"books/index.html","permalink":"http://zzuzyj.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-18T11:52:10.736Z","updated":"2022-04-18T11:52:10.736Z","comments":false,"path":"categories/index.html","permalink":"http://zzuzyj.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-18T11:52:10.734Z","updated":"2022-04-18T11:52:10.734Z","comments":false,"path":"about/index.html","permalink":"http://zzuzyj.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-04-18T11:52:10.737Z","updated":"2022-04-18T11:52:10.737Z","comments":false,"path":"repository/index.html","permalink":"http://zzuzyj.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-18T11:52:10.738Z","updated":"2022-04-18T11:52:10.738Z","comments":false,"path":"tags/index.html","permalink":"http://zzuzyj.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-18T11:52:10.736Z","updated":"2022-04-18T11:52:10.736Z","comments":true,"path":"links/index.html","permalink":"http://zzuzyj.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"CF1632","slug":"CF1632","date":"2022-04-24T13:15:53.822Z","updated":"2022-04-24T13:40:48.790Z","comments":true,"path":"2022/04/24/CF1632/","link":"","permalink":"http://zzuzyj.github.io/2022/04/24/CF1632/","excerpt":"","text":"CF1632题目链接 ：http://codeforces.com/contest/1632 D. New Year Concert今天刚学了st表，这就用上了，这一题是二分+st表 题目分析 当r的值确定时，gcd(a_l,a_{l+1},....,a_r)随着l递增，而r-l+1却是递减，则两条\\\\线必有1或0个交点， 也就是说，对于每一个r，只可能有不存在或者仅有一个l使得gcd(a_l,a_{l+1},....,\\\\a_r)=r-l+1这两种情况，用ans[N]记录答案，st表记录区间gcd，对一个每一个r，用二\\\\分搜索是是否有满足条件的l,如果没有继承上一个状态，如果有，ans[i]=ans[whereL-1]+1;\\\\代码如下123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int N=200010;int a[N],lg[N],f[N][20],ans[N];int gcd(int a,int b)&#123;return b==0?a:gcd(b,a%b);&#125;int query(int l,int r)&#123; int k=lg[r-l+1]; return gcd(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i];f[i][0]=a[i]; &#125; for(int k=1;k&lt;=20;k++)&#123; for(int i=1;i+(1&lt;&lt;k)-1&lt;=n;i++)&#123; f[i][k]=gcd(f[i][k-1],f[i+(1&lt;&lt;k-1)][k-1]); &#125; &#125; lg[0]=-1; for(int i=1;i&lt;=n;i++) lg[i]=lg[i/2]+1; for(int i=1;i&lt;=n;i++)&#123; int l=1,r=i,whereL=0; while(l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if(query(mid,i)==i-mid+1)&#123;whereL=mid;break;&#125; else if(query(mid,i)&lt;i-mid+1)l=mid+1; else r=mid-1; &#125; if(!whereL)ans[i]=ans[i-1]; else ans[i]=ans[whereL-1]+1; &#125; for(int i=1;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; return 0;&#125;","categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://zzuzyj.github.io/tags/codeforces/"}]},{"title":"st表模板","slug":"st表","date":"2022-04-24T07:01:53.638Z","updated":"2022-04-24T13:12:07.483Z","comments":true,"path":"2022/04/24/st表/","link":"","permalink":"http://zzuzyj.github.io/2022/04/24/st%E8%A1%A8/","excerpt":"","text":"st表 介绍及其代码实现 1 st表创建 2 st表查询 模板题 P3865 【模板】ST 表 st表介绍及其代码实现ST （Spares Table，稀疏表） 算法主要运用了倍增的思想，初始化在O(nlogn) 时间构造一个二维表，可以用仅仅O（1)的时间处理查询区间[L,R]的最值问题，大大节省了查询的时间.另外， 例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。 设F[i,j]表示[i,i+2^j-1]区间的最值，区间长度为2^j,我们可以将其分为长度为2^{j-1}的两个区间，\\\\ 然后求两个子区间的最值，递推可得公式\\\\ f[i][j]=max(f[i][j-1],f[i+(1","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzuzyj.github.io/categories/algorithm/"},{"name":"模板","slug":"algorithm/模板","permalink":"http://zzuzyj.github.io/categories/algorithm/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"st表","slug":"st表","permalink":"http://zzuzyj.github.io/tags/st%E8%A1%A8/"},{"name":"倍增","slug":"倍增","permalink":"http://zzuzyj.github.io/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"星CTF_EZrsa","slug":"CTF_EZrsa","date":"2022-04-22T08:05:47.197Z","updated":"2022-04-22T10:42:53.239Z","comments":true,"path":"2022/04/22/CTF_EZrsa/","link":"","permalink":"http://zzuzyj.github.io/2022/04/22/CTF_EZrsa/","excerpt":"","text":"EZrsa题目12345678910111213141516171819202122from Crypto.Util.number import getStrongPrimefrom gmpy import next_primefrom random import getrandbitsfrom flag import flag p=getStrongPrime(1024)q=next_prime(p^((1&lt;&lt;900)-1)^getrandbits(300))n=p*qe=65537 m=int(flag.encode(&#x27;hex&#x27;),16)assert m&lt;nc=pow(m,e,n) print(hex(n))#0xe78ab40c343d4985c1de167e80ba2657c7ee8c2e26d88e0026b68fe400224a3bd7e2a7103c3b01ea4d171f5cf68c8f00a64304630e07341cde0bc74ef5c88dcbb9822765df53182e3f57153b5f93ff857d496c6561c3ddbe0ce6ff64ba11d4edfc18a0350c3d0e1f8bd11b3560a111d3a3178ed4a28579c4f1e0dc17cb02c3ac38a66a230ba9a2f741f9168641c8ce28a3a8c33d523553864f014752a04737e555213f253a72f158893f80e631de2f55d1d0b2b654fc7fa4d5b3d95617e8253573967de68f6178f78bb7c4788a3a1e9778cbfc7c7fa8beffe24276b9ad85b11eed01b872b74cdc44959059c67c18b0b7a1d57512319a5e84a9a0735fa536f1b3 print(hex(c))#0xd7f6c90512bc9494370c3955ff3136bb245a6d1095e43d8636f66f11db525f2063b14b2a4363a96e6eb1bea1e9b2cc62b0cae7659f18f2b8e41fca557281a1e859e8e6b35bd114655b6bf5e454753653309a794fa52ff2e79433ca4bbeb1ab9a78ec49f49ebee2636abd9dd9b80306ae1b87a86c8012211bda88e6e14c58805feb6721a01481d1a7031eb3333375a81858ff3b58d8837c188ffcb982a631e1a7a603b947a6984bd78516c71cfc737aaba479688d56df2c0952deaf496a4eb3f603a46a90efbe9e82a6aef8cfb23e5fcb938c9049b227b7f15c878bd99b61b6c56db7dfff43cd457429d5dcdb5fe314f1cdf317d0c5202bad6a9770076e9b25b1 题目分析&amp;解答p是1024位的随机素数，q=next_prime(p^((1&lt;&lt;900)-1)^getranbits(300)),即q是p异或1&lt;&lt;900-1再异或一个300bits的随机数的下一个素数 根据异或的性质，我们可以很容易得知p和q的高124位是相同的，而且n=p*q，且n是已经知道的 拆分p,q, p=p_{high}*2^{900}+p_{low}\\\\ q=q_{high}*2^{900}+q_{low}\\\\ 令x=p_{high},则x也等于q_{high}\\\\ p_{low}+q_{low}=2^{900}-1+cc,cc是300位随机数异或后的改变量，相对较小，当然不是真的小。\\\\ n=p*q(2^{1800}*x^2+2^{900}*x(p_{low}+q_{low})\\\\+p_{low}*q_{low})=2^{1800}*x^2+2^{1800}*x+smallnum,两边//2^{1800}得到\\\\ n//2^{1800}=x^2+x,x可解直接开根可得x 12345from gmpy2 import irootn=0xe78ab40c343d4985c1de167e80ba2657c7ee8c2e26d88e0026b68fe400224a3bd7e2a7103c3b01ea4d171f5cf68c8f00a64304630e07341cde0bc74ef5c88dcbb9822765df53182e3f57153b5f93ff857d496c6561c3ddbe0ce6ff64ba11d4edfc18a0350c3d0e1f8bd11b3560a111d3a3178ed4a28579c4f1e0dc17cb02c3ac38a66a230ba9a2f741f9168641c8ce28a3a8c33d523553864f014752a04737e555213f253a72f158893f80e631de2f55d1d0b2b654fc7fa4d5b3d95617e8253573967de68f6178f78bb7c4788a3a1e9778cbfc7c7fa8beffe24276b9ad85b11eed01b872b74cdc44959059c67c18b0b7a1d57512319a5e84a9a0735fa536f1b3nn=n//(2**1800)print(iroot(nn,2)[0])#20226195070633070235386534147535171929 即x=20226195070633070235386534147535171929, 接下来就是如何求p,q了，由于p+q为定值，可知若p==q，p*q越大，当p,q越不相近p,q越小，再根据n，我们可以求出,p,q的大概值 12345678910x=20226195070633070235386534147535171929p = x&lt;&lt;900 | (2**900 - 1)q = x&lt;&lt;900# Start from 125th bits (1024-125)for i in range(899, 301, -1): cur = 1&lt;&lt;i if (p^^cur) * (q^^cur) &lt; n: p^^= cur q^^= curprint(hex(p)) 由性质可知p的大概值和真实的p存在差异，但是具体不知道，然后可以继续进行爆破，截取一部分足够的高位进行coppersmith爆破， 我们直接截取coppersmith所能爆破的最大限度，如果还没结果就寄吧 1234567891011121314from libnum import *n = p = c = PR.&lt;x&gt; = PolynomialRing(Zmod(n))f=x+proots=f.small_roots(X=2**430,beta=0.4)p=int(p+roots[0])assert n%p==0q = n//pphi = (p-1)*(q-1)d = inverse(65537, phi)print(n2s(int(pow(c,d,n))))# *CTF&#123;St.Diana_pls_take_me_with_you!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://zzuzyj.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://zzuzyj.github.io/tags/RSA/"}]},{"title":"CF1669(Div.4)","slug":"CF1669(Div_4)","date":"2022-04-22T05:52:24.314Z","updated":"2022-04-24T11:01:46.526Z","comments":true,"path":"2022/04/22/CF1669(Div_4)/","link":"","permalink":"http://zzuzyj.github.io/2022/04/22/CF1669(Div_4)/","excerpt":"","text":"Codeforces Round #784 (Div. 4) A Division? B Triple C Odd/Even Increments D. Colorful Stamp E. 2-Letter Strings F. Eating Candies G. Fall Down H. Maximal AND Codeforces Round #784 (Div. 4)新人菜鸡，没有ak，说实话题目英语真没看懂，来补个题 A Division?简单if else判断语句 1234567891011121314151617#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int maxn=1e6+10;int main()&#123; int tt;cin&gt;&gt;tt; while(tt--)&#123; cout&lt;&lt;&quot;Division &quot;&lt;&lt;endl; int n;cin&gt;&gt;n; if(n&gt;=1900)cout&lt;&lt;1&lt;&lt;endl; else if(n&gt;=1600)cout&lt;&lt;2&lt;&lt;endl; else if(n&gt;=1400)cout&lt;&lt;3&lt;&lt;endl; else cout&lt;&lt;4&lt;&lt;endl; &#125; return 0;&#125; B Triple数据范围不大，直接可以用数组存数据，最后判定是否存在ans[i]&gt;=3,if ok ,输出 i，没有输出 -1 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int maxn=2*1e5+10;int ans[maxn];int main()&#123; // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; memset(ans,0,sizeof(ans)); int n;cin&gt;&gt;n; int flag=-1; for(int i=1;i&lt;=n;i++)&#123; int t;cin&gt;&gt;t; ans[t]++; if(ans[t]&gt;=3)flag=t; &#125; cout&lt;&lt;flag&lt;&lt;endl; &#125; return 0;&#125; C Odd/Even Incrementsc题是个奇偶判定，要求奇数位必须都是奇数或偶数，偶数位必须也都是奇数或偶数 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1e3+10;int a[maxn];int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); //freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; memset(a,0,sizeof(a)); int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; int flag1=a[1]%2,flag2=a[2]%2,flag=1; for(int i=3;i&lt;=n;i++)&#123; if(i%2==1)&#123; if(a[i]%2!=flag1)&#123; flag=0;break;&#125; &#125; else if(a[i]%2!=flag2)&#123;flag=0;break;&#125; &#125; if(flag)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125; D. Colorful Stamp结论判定，如果一段区间被染色，必存在r,b两种颜色，o(n)扫一遍即可 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int n;char a[200005];int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; cin&gt;&gt;n; scanf(&quot;%s&quot;,a+1); bool flag=1; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==&#x27;W&#x27;)continue; int j=i; while(j&lt;n&amp;&amp;a[j+1]!=&#x27;W&#x27;)j++; bool flag1=0,flag2=0; for(int k=i;k&lt;=j;k++)&#123; if(a[k]==&#x27;R&#x27;)flag1=1; if(a[k]==&#x27;B&#x27;)flag2=1; &#125; if(!(flag1&amp;&amp;flag2))flag=0; i=j; &#125; if(flag)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; E. 2-Letter Strings我们可以统计只有出现重复字符的字符数，相同的话减去，用mp1存第一个位置，mp2存第二个位置，mp存字符串，出现过的话-mp[s]*2 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;#define int long longmap&lt;char,int&gt;mp1,mp2;map&lt;string,int&gt;mp;signed main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; mp.clear();mp1.clear();mp2.clear(); int n;cin&gt;&gt;n;int ans=0; for(int i=1;i&lt;=n;i++)&#123; string s;cin&gt;&gt;s; ans+=((mp1[s[0]]++)+(mp2[s[1]]++)-(mp[s]++)*2); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; F. Eating Candies做一个前缀和，左右指针往中间走，判断sum[l]与sum[n]-sum[r-1] 的关系，如果大于，l++,如果等于 用ans记录答案=l+n+1-r,r—;其他r— 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int maxn=2*1e5+10;int sum[maxn];int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; int n,a;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;a;sum[i]=sum[i-1]+a[i];&#125; int l=1,r=n,ans=0; while(l&lt;r)&#123; if(sum[l]&lt;(sum[n]-sum[r-1]))l++; else if(sum[l]==(sum[n]-sum[r-1]))ans=l+n-r+1,r--; else r--; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; G. Fall Down，初始化在每一列的下面加一块o，记录在o出现前的*的数量，最后直接给数组赋值即可，o上面一定全是石头，石头上到 o前全是. 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int maxn=55;char a[maxn][maxn];int main()&#123; int tt;cin&gt;&gt;tt; while(tt--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j]; for(int i=1;i&lt;=m;i++)a[n+1][i]=&#x27;o&#x27;; for(int i=1;i&lt;=m;i++)&#123; int cnt=0,st=1; for(int j=1;j&lt;=n+1;j++)&#123; if(a[j][i]==&#x27;*&#x27;)cnt++; else if(a[j][i]==&#x27;.&#x27;)continue; else if(a[j][i]==&#x27;o&#x27;)&#123; for(int k=st;k&lt;=j-1;k++)&#123; a[k][i]=&#x27;.&#x27;; &#125; for(int k=j-cnt;k&lt;j;k++)&#123; a[k][i]=&#x27;*&#x27;; &#125; st=j+1,cnt=0; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)cout&lt;&lt;a[i][j];cout&lt;&lt;&#x27;\\n&#x27;;&#125; &#125; return 0;&#125; H. Maximal AND思考or和and的定义，发现题目是让我们计算高位到地位的1的数，当然这只是前提，计算0-30每一位1 个数的和，如果为n，则此位的and值为 1&gt;&gt;j ,j为位数，只要把30-0扫一遍，判断k是否够用，ans+=1&gt;&gt;j即可 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; int n,k;cin&gt;&gt;n&gt;&gt;k; int cnt[35]=&#123;0&#125;; for(int i=1;i&lt;=n;i++)&#123; int t;cin&gt;&gt;t; for(int i=0;i&lt;=30;i++)&#123; if(1&amp;(t&gt;&gt;i))cnt[i]++; &#125; &#125; int ans=0; for(int i=30;i&gt;=0;i--)&#123; if(k&gt;=n-cnt[i])&#123; k-=(n-cnt[i]); ans+=1&lt;&lt;i; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://zzuzyj.github.io/tags/codeforces/"}]},{"title":"numpylearn","slug":"numpylearn","date":"2022-04-20T12:34:41.641Z","updated":"2022-04-23T01:55:47.809Z","comments":true,"path":"2022/04/20/numpylearn/","link":"","permalink":"http://zzuzyj.github.io/2022/04/20/numpylearn/","excerpt":"","text":"numpy 官方文档 https://numpy.org/doc/stable/reference/ 初识数组 初始数组 认识类型 查询属性 初始赋值 类型转换 一维操作 索引切片 元素运算 矢量运算 搜索排序 数理统计 numpy官方文档 初识数组初始数组array()12345import numpy as npls=[1,2,3,4,5,6,7,8]a=np.array(ls)print(a)# [1 2 3 4 5 6 7 8] 认识类型dtype12345678910111213141516import numpy as np# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]a =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.bool)b =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.int8)c =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.uint8)d =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.float16)print(a,a.dtype)print(b,b.dtype)print(c,c.dtype)print(d,d.dtype) #[False True True True True True True True True True] bool#[0 1 2 3 4 5 6 7 8 9] int8#[0 1 2 3 4 5 6 7 8 9] uint8#[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] float16 查询属性 属性 说明 .dtype 数组元素的数据类型 .ndim 数组的维度的个数 .shape 数组的形状 .size 数组元素的总数 .itemsize 数组中的每个元素的字节大小 1234567891011121314151617181920import numpy as npa = np.array([ [4.8, 6], [4.38, 5.5], [4.45, 6], [9.5, 12.8], [3.5, 5.5], [3.5, 5.5], [9.5, 12.8], [1.875, 2.3], [1.875, 2.3], [1.875, 2.3], [4.38, 5.5], [4.4, 5.5], [4.4, 5.5], [4.4, 5.5], [4.45, 6], [4.45, 6], [4.45, 6], ])print(&quot;类型：&#123;&#125;&quot;.format(a.dtype))print(&quot;维度：&#123;&#125;&quot;.format(a.ndim))print(&quot;形状：&#123;&#125;&quot;.format(a.shape))print(&quot;元素总数：&#123;&#125;&quot;.format(a.size))print(&quot;元素字节大小：&#123;&#125;&quot;.format(a.itemsize))print(&quot;数组所占内存空间：&#123;&#125;&quot;.format(a.size*a.itemsize))# 类型：float64# 维度：2# 形状：(17, 2)# 元素总数：34# 元素字节大小：8# 数组所占内存空间：272 初始赋值 函数 说明 np.arange() 类似range()函数 np.ones(shape) 根据shape生成一个全一的数组，shape是一个元组 np.zeros(shape) 根据shape生成一个全0数组，shape是一个元组 np.linspace() 根据气质数据等间距地填充数据，形成数组 np.concatetenate() 将两个或多个数组合并成一个新的数组 np.full(shape,val) 根据shape生成一个全为val的数组 np.eye(n) 创建一个n*n的矩阵，对角线为1,其余为0 np.ones_like(a) 根据a的形状生成一个全为1的数组 np.zeros_like(a) 根据a的形状生成一个全为0的数组 np.full_like(a,val) 根据a的形状生成一个全为val的数组 1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as plta = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.arange(0.1, 2.0, 0.1))print(&quot;&gt;&gt;&gt; &quot;, np.ones(10))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, np.ones((3, 3)))print(&quot;&gt;&gt;&gt; &quot;, np.zeros(8))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, np.linspace(1, 2))print(&quot;&gt;&gt;&gt; &quot;, np.linspace(1, 2, endpoint=False))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, np.linspace(1, 2, num=5))x1 = np.linspace(0, 1, num=10)x2 = np.linspace(1, 2, num=10)y = np.zeros(10)plt.plot(x1, y, &quot;o&quot;)plt.plot(x2, y, &quot;o&quot;)plt.show() 12345678910import numpy as npimport matplotlib.pyplot as plta = np.arange(0, 10)b = np.arange(10, 20)print(&quot;&gt;&gt;&gt; &quot;, np.concatenate((a, b)))data = np.random.normal(2, 0.1, 100000)plt.hist(data, 1000)plt.show() 123456import numpy as npimport matplotlib.pyplot as pltdata = np.random.beta(2, 2, 100000)plt.hist(data, 1000)plt.show() 等等…… 类型转换 函数 属性 .astype(new_type) 强制转换数组的数据类型 .tolist() 返回数组数据的副本作为（嵌套的）python列表 123456789101112131415import numpy as npa = np.arange(1, 5, 0.5)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, a.dtype)print(&quot;&gt;&gt;&gt; &quot;, a.astype(np.int32))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([[1, 2, 5], [6, 3, 4], [5, 6, 0]])b = a.tolist()print(&quot;&gt;&gt;&gt; &quot;, b)print(&quot;&gt;&gt;&gt; &quot;, type(b))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([&quot;1.2&quot;, &quot;2.4&quot;, &quot;3.1415&quot;])print(&quot;&gt;&gt;&gt; &quot;, a.itemsize * a.size)print(&quot;&gt;&gt;&gt; &quot;, a.astype(np.float64)) 一维操作索引切片12345678910111213import numpy as npa = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, a[-1])print(&quot;&gt;&gt;&gt; &quot;, a[9])print(&quot;&gt;&gt;&gt; &quot;, a[1])print(&quot;&gt;&gt;&gt; &quot;, a[[1, 5, 2]])# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; 9# &gt;&gt;&gt; 9# &gt;&gt;&gt; # &gt;&gt;&gt; [1 5 2] 1234567891011121314151617import numpy as npa = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)b = [True, True, False, False, False, True, True, False, False, False]print(&quot;&gt;&gt;&gt; &quot;, a[b])print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, a[1:4])print(&quot;&gt;&gt;&gt; &quot;, a[0:6:2])# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [0 1 5 6]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [1 2 3]# &gt;&gt;&gt; [0 2 4] 1234567891011121314151617181920212223242526import numpy as npa = np.arange(10)b = a[0:6]print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)b[1] = 1000print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)print(&quot;------------------------------------------------------------------------------------------&quot;)a = list(range(10))b = a[0:6]print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)b[1] = 1000print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [0 1 2 3 4 5]# &gt;&gt;&gt; [ 0 1000 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [ 0 1000 2 3 4 5]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# &gt;&gt;&gt; [0, 1, 2, 3, 4, 5]# &gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# &gt;&gt;&gt; [0, 1000, 2, 3, 4, 5] 元素运算 函数 属性 函数 属性 abs 计算绝对值 divide 数组元素相除 fabs 计算绝对值，比abs快 floor_divide 返回整数结果，先调用divide，再调用floor函数 sqrt 以元素为单位返回数组的非负平方根 power 第一个数组元素从第二个数组逐元素提升为幂s。 square 返回输入的元素的平方 maximum 数组元素最大值 exp 计算输入数组中所有元素的指数 fmax 数组元素最大值 log 底数计算 minimum 数组元素最小值 rint 将数组的元素四舍五入 fmin 数组元素最小值 ceil 向上取整 mod 返回元素的除法余数 floor 向下取整 copysign 按元素方式将x1的符号更改为x2的符号 isnan 对nan逐个元素进行测试，并返回bool数组 greater 返回x1&gt;x2的真值 cos 返回余弦值 greater_equal 返回x1&gt;=x2的真值 sin 返回正弦值 less 返回x1&lt;x2的真值 arctanh 反双曲函数的返回值 less_equal 返回x1&lt;=x2的真值 add 逐元素相加 equal 返回x1=x2的真值 subtract 逐元素相减 not_equal 返回x1!=x2的真值 multiply 逐元素相乘 12345678910111213141516171819202122232425import numpy as npa = np.arange(-10, 10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.abs(a))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.sqrt(a))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.random.randint(0, 100, 15)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.max(a))# &gt;&gt;&gt; [-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7# 8 9]# &gt;&gt;&gt; [10 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [0. 1. 1.41421356 1.73205081 2. 2.23606798# 2.44948974 2.64575131 2.82842712 3. ]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [ 1 74 33 21 22 59 57 56 26 25 85 0 8 53 38]# &gt;&gt;&gt; 85 123456789101112131415161718192021222324252627282930import numpy as npa = np.arange(10)b = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a, b)c = np.ones(10)d = np.add(a, b, out=c)print(&quot;&gt;&gt;&gt; &quot;, c)print(&quot;&gt;&gt;&gt; &quot;, id(c), id(d))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([3, 5, 2, 5, 7, 4, 7, 0])b = np.array([0, 9, 0, 9, 0, 9, 0, 9])print(&quot;&gt;&gt;&gt; &quot;, np.maximum(a, b))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([3, 5, 2, 5, 7, 4, 7, 0])b = np.array([0, 9, 0, 9, 0, 9, 0, 9])c = np.greater(a, b)print(&quot;&gt;&gt;&gt; &quot;, c)print(&quot;&gt;&gt;&gt; &quot;, a[c])# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [ 0. 2. 4. 6. 8. 10. 12. 14. 16. 18.]# &gt;&gt;&gt; 2591797890768 2591797890768# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [3 9 2 9 7 9 7 9]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [ True False True False True False True False]# &gt;&gt;&gt; [3 2 7 7] 矢量运算四则运算 123456789import numpy as npx = np.array([4, 3, 6, 7, 4, 2, 5, 6])y = np.array([1, 1, 0, 0, 1, 1, 0, 0])print(&quot;&gt;&gt;&gt; &quot;, x * 2)print(&quot;&gt;&gt;&gt; &quot;, x + y, x - y, x * y, x / y)# &gt;&gt;&gt; [ 8 6 12 14 8 4 10 12]# &gt;&gt;&gt; [5 4 6 7 5 3 5 6] [3 2 6 7 3 1 5 6] [4 3 0 0 4 2 0 0] [ 4. 3. inf inf 4. 2. inf inf] 复杂的逻辑运算和多元运算 123456789101112131415161718192021222324252627282930import numpy as npx = np.array([4, 3, 6, 7, 4, 2, 5, 6])y = np.array([1, 1, 0, 0, 1, 1, 0, 0])print(&quot;&gt;&gt;&gt; &quot;, x &gt; 2)print(&quot;&gt;&gt;&gt; &quot;, x == 2)print(&quot;&gt;&gt;&gt; &quot;, x &lt; 2)print(&quot;&gt;&gt;&gt; &quot;, x &gt; y, x == y)print(&quot;&gt;&gt;&gt; &quot;, np.logical_and(x, y))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, x[x &gt; 5])x[x == 4] = 99print(&quot;&gt;&gt;&gt; &quot;, x)x[y == 0] = 0print(&quot;&gt;&gt;&gt; &quot;, x)print(&quot;------------------------------------------------------------------------------------------&quot;)x = np.array([-4, -3, 6, -7, 4, -2, 5, -6])print(&quot;&gt;&gt;&gt; &quot;, np.where(x &gt; 0, 1, -1))# &gt;&gt;&gt; [ True True True True True False True True]# &gt;&gt;&gt; [False False False False False True False False]# &gt;&gt;&gt; [False False False False False False False False]# &gt;&gt;&gt; [ True True True True True True True True] [False False False False False False False False]# &gt;&gt;&gt; [ True True False False True True False False]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [6 7 6]# &gt;&gt;&gt; [99 3 6 7 99 2 5 6]# &gt;&gt;&gt; [99 3 0 0 99 2 0 0]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [-1 -1 1 -1 1 -1 1 -1] 搜索排序 函数 说明 numpy.sort() 返回数组的排序副本 ndarray.sort() 就地排序数组 numpy.searchsorted() 查找应在其中插入元素以保持顺序的索引 numpy.count_nonzero() 统计数组非0个数 numpy.where() 根据条件从x或者y中选择返回的元素 123456789101112import numpy as npimport matplotlib.pyplot as plta = np.random.randint(0, 100, 200)plt.scatter(range(200), a)plt.show()np.sort(a)plt.scatter(range(200), a)plt.show()a.sort()plt.scatter(range(200), a)plt.show() 123456789101112131415161718192021import numpy as npa = np.random.randint(0, 100, 10)a.sort()print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.searchsorted(a, 5))print(&quot;&gt;&gt;&gt; &quot;, np.insert(a, np.searchsorted(a, 5), 5))print(&quot;&gt;&gt;&gt; &quot;, np.append(a, 100))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([1, 2, 3, 1, 1, 1, 2, 3, 4])print(&quot;&gt;&gt;&gt; &quot;, np.where(a == 1))a = np.array([0, 1, 0, 2, 0, 2, 0, 3, 0, 4])print(&quot;&gt;&gt;&gt; &quot;, np.count_nonzero(a))# &gt;&gt;&gt; [11 23 32 47 57 64 68 72 86 86]# &gt;&gt;&gt; 0# &gt;&gt;&gt; [ 5 11 23 32 47 57 64 68 72 86 86]# &gt;&gt;&gt; [ 11 23 32 47 57 64 68 72 86 86 100]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; (array([0, 3, 4, 5], dtype=int64),)# &gt;&gt;&gt; 5 数理统计统计函数和集合运算函数 函数 说明 np.sum() 计算数组元素的总和 np.mean() 计算数组元素的平均值 np.std() 计算数组的标准差 np.average() 计算数组的加权平均值 np.cumsum() 数组元素的累加和(前缀和数组) np.cumprod() 数组元素的累乘积 np.unique(x) 计算x中的唯一元素,并返回有序结果 np.intersectld(x,y) 计算x和y的公共元素，返回有序结果 np.unionld(x,y) 计算x和 y的并集，返回有序结果 np.inld(x,y) 得到一个表示x 的元素是否包含于y的布尔型数组 np.setdiffld(x,y) 集合差，即元素在x中且不在y中 np.setxorld(x,y) 集合对称差，在一个数组中单不同时存在于两个数组 123456789101112131415161718192021222324252627import numpy as npa = np.arange(101)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.sum(a))print(&quot;&gt;&gt;&gt; &quot;, np.mean(a))print(&quot;&gt;&gt;&gt; &quot;, np.std(a))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([80, 67, 61])print(&quot;&gt;&gt;&gt; &quot;, np.average(a))print(&quot;&gt;&gt;&gt; &quot;, np.mean(a))weight = [60, 20, 20]print(&quot;&gt;&gt;&gt; &quot;, np.average(a, weights=weight))# &gt;&gt;&gt; [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17# 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35# 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53# 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71# 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89# 90 91 92 93 94 95 96 97 98 99 100]# &gt;&gt;&gt; 5050# &gt;&gt;&gt; 50.0# &gt;&gt;&gt; 29.154759474226502# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; 69.33333333333333# &gt;&gt;&gt; 69.33333333333333# &gt;&gt;&gt; 73.6","categories":[{"name":"python","slug":"python","permalink":"http://zzuzyj.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"http://zzuzyj.github.io/tags/numpy/"}]},{"title":"RSA攻击","slug":"RSA","date":"2022-04-18T12:29:33.706Z","updated":"2022-04-19T03:01:04.826Z","comments":true,"path":"2022/04/18/RSA/","link":"","permalink":"http://zzuzyj.github.io/2022/04/18/RSA/","excerpt":"","text":"基础类型，给定p,q,e,c12345678910from libnum import *p=q=e=c=n=p*qphi=(p-1)*(q-1)d=invmod(e,phi)m=pow(c,d,n)print(n2s(int(m))) 可直接分解的N（p,q）运用yafu分解 运用网站在线分解 http://www.factordb.com 小e攻击e非常小，可以直接开根拿到m 123456789101112from gmpy2 import *from libnum import *k=0e=c=n=while True: m=c+n*k k+=1 flag=iroot(m,e) if(flag[0]): print(n2s(int(flag[1]))) 共模攻击（n,m相同，c,e不同）n不变，可以根据e1,e2,c1,c2,n可以不求d1,d2直接求解m e1,e2互素 gcd(e1,e2)=1 则 e1*s1+e2*s2=1,s1,s2均为整数，s1,s2一正一负，通过gmpy2 的gcdext(e1,e2)可以计算出(s1,s2)\\\\又 c_1 \\equiv m^{e_1} \\bmod n,c_2\\equiv m^{e_2}\\bmod n.\\\\ 则(c_1^{s_1}c_2^{s_2})\\bmod n = ((m^{e_1}\\bmod n)^{s_1}(m^{e_2}\\bmod n)^{s_2})\\bmod n\\\\ 化简 (c_1^{s_1}c_2^{s_2})\\bmod n = (m^{e_1s_1+e_2s_2})\\bmod n\\\\ 又e1*s1+e2*s2=1\\\\ 则c_1^{s_1}*c_2^{s_2}=m12345678910111213141516171819from gmpy2 import *from libnum import *def deattack(e1,e2,c1,c2,n): g,s1,s2=gcdext(e1,e2) if s1&lt;0: s1=-s1 c1=invert(c1,n) if s2&lt;0: s2=-s2 c2=invert(c2,n) m=pow(c1,s1,n)*pow(c2,s2,n)%n return int(m)e1=e2=c1=c2=n=flag=deattack(e1,e2,c1,c2,n)print(n2s(flag))","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://zzuzyj.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://zzuzyj.github.io/tags/RSA/"}]}],"categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"},{"name":"algorithm","slug":"algorithm","permalink":"http://zzuzyj.github.io/categories/algorithm/"},{"name":"模板","slug":"algorithm/模板","permalink":"http://zzuzyj.github.io/categories/algorithm/%E6%A8%A1%E6%9D%BF/"},{"name":"Crypto","slug":"Crypto","permalink":"http://zzuzyj.github.io/categories/Crypto/"},{"name":"python","slug":"python","permalink":"http://zzuzyj.github.io/categories/python/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://zzuzyj.github.io/tags/codeforces/"},{"name":"st表","slug":"st表","permalink":"http://zzuzyj.github.io/tags/st%E8%A1%A8/"},{"name":"倍增","slug":"倍增","permalink":"http://zzuzyj.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"RSA","slug":"RSA","permalink":"http://zzuzyj.github.io/tags/RSA/"},{"name":"numpy","slug":"numpy","permalink":"http://zzuzyj.github.io/tags/numpy/"}]}